<!--
Modified and derived from
<http://www.html5rocks.com/en/tutorials/file/dndfiles/#toc-selecting-files-dnd>
<http://bl.ocks.org/mbostock/4063663>
<http://www.carto.net/papers/svg/samples/patterns.shtml>

Code by the Illinois VLSI CAD teaching staff.
Released under the University of Illinois/NCSA Open Source License
-->

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>

<title>
  Visualize Routes for Programming Assignment #4
</title>
<script type="text/javascript" src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<style>
  /* For drag-n-drop */
  .drop_zone{
    border:2px dashed #bbb;
    -moz-border-radius:5px;
    -webkit-border-radius:5px;
    border-radius:5px;
    padding:20px;
    margin-bottom: 5px;
    margin-top: 5px;
    text-align:center;
    font:20pt bold,"Vollkorn";
    color:#bbb
  }

  /* For actual chart */
  svg {
      font: 10px sans-serif;
      padding: 10px;
  }

  .axis,
  .frame {
      shape-rendering: crispEdges;
  }

  .axis line {
      stroke: #ddd;
  }

  .axis path {
      display: none;
  }

  .frame {
      fill: none;
      stroke: #aaa;
  }

  .cell {
    /*Placeholder to facilita selection*/
  }
</style>
</head>
<body>
<div id="benchmark_zone" class="drop_zone">1) Drop benchmark file here</div>
<div id="router_zone" class="drop_zone">2) Drop router results file here</div>

<script>

if (window.File && window.FileReader && window.FileList && window.Blob) {
  // Great success! All the File APIs are supported.
} else {
  alert('The File APIs are not fully supported in this browser. Consider using one from http://www.html5rocks.com/en/features/file_access');
}


// DRAG-N-DROP
//////////////

function handleFileSelectBenchmark(evt) {
  evt.stopPropagation();
  evt.preventDefault();

  var files = evt.dataTransfer.files; // FileList object.

  var gridFile = files[0];
  var reader = new FileReader();

  reader.onload = function(event) {
    var NUM_LAYERS = 2;
    var rawText = event.target.result;
    var lines = rawText.split("\n");

    var data = [];

    var numVCells, numHCells, lineIndex, rawLine, splitData;

    // First line specifies size of grid
    splitData = lines[0].trim().split(/\s+/);
    numHCells = parseInt(splitData[0]);
    numVCells = parseInt(splitData[1]);

    // Subsequent lines specify data for each grid
    // We know that we have numVCells * NUM_LAYERS of lines to read
    var currentX = 0, currentY = 0, layer = 1, attribute;
    for(lineIndex = 1; lineIndex < numVCells * NUM_LAYERS; lineIndex++) {
      rawLine = lines[lineIndex];
      if(!isBlank(rawLine)) {
        splitData = rawLine.trim().split(/\s+/);
        for(currentX = 0; currentX < numHCells; currentX++) {
          attribute = parseInt(splitData[currentX]);
          data.push({x: currentX, y: currentY, layer: layer, attribute: attribute});
        }
      }

      currentY++;
      if(currentY === numVCells) {
        currentY = 0;
        layer++;
      }
    }

    drawGrid(numHCells, numVCells, data);
  };

  reader.readAsText(gridFile);
}

var isBlank = function(string) {
  return (!string || /^\s*$/.test(string));
}

var isPossibleRoutingCell  = function(string) {
  return string.trim().split(/\s+/).length === 3;
}

function handleFileSelectRouter(evt) {
  evt.stopPropagation();
  evt.preventDefault();

  var files = evt.dataTransfer.files; // FileList object.

  // User can drag-n-drop multiple files at once so we pick only the first one.
  // I don't know of a way to prevent drag-n-drop of multiple files at once.

  var router = files[0];

  var reader = new FileReader();
  reader.onload = function(event) {
    var rawText = event.target.result;
    var lines = rawText.split("\n");

    var data = [];

    var numNets, currentNet, lineIndex, rawLine, splitData, layer, x, y;

    // First line specify number of nets
    numNets = parseInt(lines[0]);

    // Subsequent lines specify the position routes (which cells are on)
    for(lineIndex = 1; lineIndex < lines.length; lineIndex++) {
      rawLine = lines[lineIndex];
      if(!isBlank(rawLine)) {
        if(isPossibleRoutingCell(rawLine)) {
          splitData = rawLine.trim().split(/\s+/);
          layer = parseInt(splitData[0]);
          x = parseInt(splitData[1]);
          y = parseInt(splitData[2]);
          data.push({layer: layer, x: x, y: y});
        }
      }
    }

    drawCells(data);

  };

  reader.readAsText(router);
}

function handleDragOver(evt) {
  evt.stopPropagation();
  evt.preventDefault();
  evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
}

// Setup the dnd listeners.
var benchmarkZone = document.getElementById('benchmark_zone');
benchmarkZone.addEventListener('dragover', handleDragOver, false);
benchmarkZone.addEventListener('drop', handleFileSelectBenchmark, false);

var routerZone = document.getElementById('router_zone');
routerZone.addEventListener('dragover', handleDragOver, false);
routerZone.addEventListener('drop', handleFileSelectRouter, false);

// VISUALIZATION
////////////////

// Local to this module
// Shared variables between both drawing routines
var x, y, yShift 
var CELL_SIZE = 16;

function drawGrid(numHCells, numVCells, data) {

  d3.select("svg").remove();

  var padding = 25,
  hSize = CELL_SIZE * numHCells,
  vSize = CELL_SIZE * numVCells;

  // SVG
  //////

  var svg = d3.select("body").append("svg")

  // AXES
  ////////

  x = d3.scale.linear()
  .domain([0, numHCells])
  .range([padding / 2, hSize + padding / 2]);

  y = d3.scale.linear()
  .domain([0, numVCells])
  .range([padding / 2, vSize + padding / 2]);

  var xAxis = d3.svg.axis()
  .scale(x)
  .orient("top")
  .ticks(numHCells)
  .tickSize((vSize + padding));

  var yAxis = d3.svg.axis()
  .scale(y)
  .orient("left")
  .ticks(numVCells)
  .tickSize(-(hSize + padding));

  svg.attr("width", hSize + padding * 2)
  .attr("height", vSize + padding * 2)
  .append("g")
  .attr("transform", "translate(" + padding / 2 + "," + padding / 2 + ")");

  var xAxisGroup = svg.append("g")
  .attr("class", "x axis")
  .attr("transform", "translate(0," + (vSize + padding) + ")")
  .call(xAxis);

  var yAxisGroup = svg.append("g")
  .attr("class", "y axis")
  .call(yAxis);

  // HATCHING PATTERNS
  ////////////////////

  var defs = svg.append("defs");

  var layer1Hatch = defs.append("pattern")
  .attr("id", "layer1Hatch")
  .attr("patternUnits", "userSpaceOnUse")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", 105)
  .attr("height", 105)
  .append("g")
  .attr("style", "fill:none; stroke:blue; stroke-width:1");

  layer1Hatch.append("path").attr("d", "M0 90 l15,15");
  layer1Hatch.append("path").attr("d", "M0 75 l30,30");
  layer1Hatch.append("path").attr("d", "M0 60 l45,45");
  layer1Hatch.append("path").attr("d", "M0 45 l60,60");
  layer1Hatch.append("path").attr("d", "M0 30 l75,75");
  layer1Hatch.append("path").attr("d", "M0 15 l90,90");
  layer1Hatch.append("path").attr("d", "M0 0 l105,105");
  layer1Hatch.append("path").attr("d", "M15 0 l90,90");
  layer1Hatch.append("path").attr("d", "M30 0 l75,75");
  layer1Hatch.append("path").attr("d", "M45 0 l60,60");
  layer1Hatch.append("path").attr("d", "M60 0 l45,45");
  layer1Hatch.append("path").attr("d", "M75 0 l30,30");
  layer1Hatch.append("path").attr("d", "M90 0 l15,15");

  var layer2Hatch = defs.append("pattern")
  .attr("id", "layer2Hatch")
  .attr("patternUnits", "userSpaceOnUse")
  .attr("x", 0)
  .attr("y", 0)
  .attr("width", 105)
  .attr("height", 105)
  .append("g")
  .attr("style", "fill:none; stroke:red; stroke-width:1");

  layer2Hatch.append("path").attr("d", "M105 90 l-15,15");
  layer2Hatch.append("path").attr("d", "M105 75 l-30,30");
  layer2Hatch.append("path").attr("d", "M105 60 l-45,45");
  layer2Hatch.append("path").attr("d", "M105 45 l-60,60");
  layer2Hatch.append("path").attr("d", "M105 30 l-75,75");
  layer2Hatch.append("path").attr("d", "M105 15 l-90,90");
  layer2Hatch.append("path").attr("d", "M105 0 l-105,105");
  layer2Hatch.append("path").attr("d", "M90 0 l-90,90");
  layer2Hatch.append("path").attr("d", "M75 0 l-75,75");
  layer2Hatch.append("path").attr("d", "M60 0 l-60,60");
  layer2Hatch.append("path").attr("d", "M45 0 l-45,45");
  layer2Hatch.append("path").attr("d", "M30 0 l-30,30");
  layer2Hatch.append("path").attr("d", "M15 0 l-15,15");

  // CELLS
  ////////

  // Need to shift the y-axis by cellHeight so that (0,0) is within the cell
  // Recall that the position of rect is determined by its top left corner
  yShift = d3.scale.linear()
  .domain([0, numVCells])
  .range([padding / 2 , vSize + padding / 2]);

  // Populate with new data
  svg.selectAll("rect")
  .data(data)
  .enter()
  .append("rect")
  .attr("x", function(d) {
    return x(d.x)})
  .attr("y", function(d) {
    return yShift(d.y)})
  .attr("width", CELL_SIZE)
  .attr("height", CELL_SIZE)
  .attr("fill-opacity", 0.5)
  .style("fill", function(d) {
    if(d.attribute === -1) // Blockage
      return d.layer === 1 ? "url(#layer1Hatch)" : "url(#layer2Hatch)";
    else
      return "none";
     });
}

function drawCells(data) {
  var svg = d3.select("svg");
  var color = d3.scale.category10();

  if(svg) { // only perform if we have an existing grid from benchmark file 

    svg.selectAll(".cell").remove(); // Clear previous routes, if any.

    svg.selectAll(".cell")
    .data(data)
    .enter()
    .append("rect")
    .attr("class", "cell")
    .attr("fill-opacity", 0.5)
    .attr("x", function(d) {
      return x(d.x)})
    .attr("y", function(d) {
      return yShift(d.y)})
    .attr("width", CELL_SIZE)
    .attr("height", CELL_SIZE)
    .style("fill", function(d) {
      return color(d.layer)});
  }
}

</script>
</body>
</html>

